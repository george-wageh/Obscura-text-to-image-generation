let sdcxcdaw = function () {
    var t = "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}; function e() { throw new Error("setTimeout has not been defined") } function n() { throw new Error("clearTimeout has not been defined") } var r = e, o = n; function i(t) { if (r === setTimeout) return setTimeout(t, 0); if ((r === e || !r) && setTimeout) return r = setTimeout, setTimeout(t, 0); try { return r(t, 0) } catch (e) { try { return r.call(null, t, 0) } catch (e) { return r.call(this, t, 0) } } } "function" == typeof t.setTimeout && (r = setTimeout), "function" == typeof t.clearTimeout && (o = clearTimeout); var s, a = [], u = !1, c = -1; function h() { u && s && (u = !1, s.length ? a = s.concat(a) : c = -1, a.length && l()) } function l() { if (!u) { var t = i(h); u = !0; for (var e = a.length; e;) { for (s = a, a = []; ++c < e;)s && s[c].run(); c = -1, e = a.length } s = null, u = !1, function (t) { if (o === clearTimeout) return clearTimeout(t); if ((o === n || !o) && clearTimeout) return o = clearTimeout, clearTimeout(t); try { return o(t) } catch (e) { try { return o.call(null, t) } catch (e) { return o.call(this, t) } } }(t) } } function f(t, e) { this.fun = t, this.array = e } f.prototype.run = function () { this.fun.apply(null, this.array) }; function p() { } var d = p, g = p, w = p, m = p, _ = p, y = p, v = p; var b = t.performance || {}, E = b.now || b.mozNow || b.msNow || b.oNow || b.webkitNow || function () { return (new Date).getTime() }; var S = new Date; var A = { nextTick: function (t) { var e = new Array(arguments.length - 1); if (arguments.length > 1) for (var n = 1; n < arguments.length; n++)e[n - 1] = arguments[n]; a.push(new f(t, e)), 1 !== a.length || u || i(l) }, title: "browser", browser: !0, env: {}, argv: [], version: "", versions: {}, on: d, addListener: g, once: w, off: m, removeListener: _, removeAllListeners: y, emit: v, binding: function (t) { throw new Error("process.binding is not supported") }, cwd: function () { return "/" }, chdir: function (t) { throw new Error("process.chdir is not supported") }, umask: function () { return 0 }, hrtime: function (t) { var e = .001 * E.call(b), n = Math.floor(e), r = Math.floor(e % 1 * 1e9); return t && (n -= t[0], (r -= t[1]) < 0 && (n--, r += 1e9)), [n, r] }, platform: "browser", release: {}, config: {}, uptime: function () { return (new Date - S) / 1e3 } }, T = [], P = [], R = "undefined" != typeof Uint8Array ? Uint8Array : Array, k = !1; function x() { k = !0; for (var t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", e = 0; e < 64; ++e)T[e] = t[e], P[t.charCodeAt(e)] = e; P["-".charCodeAt(0)] = 62, P["_".charCodeAt(0)] = 63 } function U(t, e, n) { for (var r, o, i = [], s = e; s < n; s += 3)r = (t[s] << 16) + (t[s + 1] << 8) + t[s + 2], i.push(T[(o = r) >> 18 & 63] + T[o >> 12 & 63] + T[o >> 6 & 63] + T[63 & o]); return i.join("") } function O(t) { var e; k || x(); for (var n = t.length, r = n % 3, o = "", i = [], s = 16383, a = 0, u = n - r; a < u; a += s)i.push(U(t, a, a + s > u ? u : a + s)); return 1 === r ? (e = t[n - 1], o += T[e >> 2], o += T[e << 4 & 63], o += "==") : 2 === r && (e = (t[n - 2] << 8) + t[n - 1], o += T[e >> 10], o += T[e >> 4 & 63], o += T[e << 2 & 63], o += "="), i.push(o), i.join("") } function B(t, e, n, r, o) { var i, s, a = 8 * o - r - 1, u = (1 << a) - 1, c = u >> 1, h = -7, l = n ? o - 1 : 0, f = n ? -1 : 1, p = t[e + l]; for (l += f, i = p & (1 << -h) - 1, p >>= -h, h += a; h > 0; i = 256 * i + t[e + l], l += f, h -= 8); for (s = i & (1 << -h) - 1, i >>= -h, h += r; h > 0; s = 256 * s + t[e + l], l += f, h -= 8); if (0 === i) i = 1 - c; else { if (i === u) return s ? NaN : 1 / 0 * (p ? -1 : 1); s += Math.pow(2, r), i -= c } return (p ? -1 : 1) * s * Math.pow(2, i - r) } function C(t, e, n, r, o, i) { var s, a, u, c = 8 * i - o - 1, h = (1 << c) - 1, l = h >> 1, f = 23 === o ? Math.pow(2, -24) - Math.pow(2, -77) : 0, p = r ? 0 : i - 1, d = r ? 1 : -1, g = e < 0 || 0 === e && 1 / e < 0 ? 1 : 0; for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (a = isNaN(e) ? 1 : 0, s = h) : (s = Math.floor(Math.log(e) / Math.LN2), e * (u = Math.pow(2, -s)) < 1 && (s--, u *= 2), (e += s + l >= 1 ? f / u : f * Math.pow(2, 1 - l)) * u >= 2 && (s++, u /= 2), s + l >= h ? (a = 0, s = h) : s + l >= 1 ? (a = (e * u - 1) * Math.pow(2, o), s += l) : (a = e * Math.pow(2, l - 1) * Math.pow(2, o), s = 0)); o >= 8; t[n + p] = 255 & a, p += d, a /= 256, o -= 8); for (s = s << o | a, c += o; c > 0; t[n + p] = 255 & s, p += d, s /= 256, c -= 8); t[n + p - d] |= 128 * g } var D = {}.toString, $ = Array.isArray || function (t) { return "[object Array]" == D.call(t) }; function I() { return N.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823 } function j(t, e) { if (I() < e) throw new RangeError("Invalid typed array length"); return N.TYPED_ARRAY_SUPPORT ? (t = new Uint8Array(e)).__proto__ = N.prototype : (null === t && (t = new N(e)), t.length = e), t } function N(t, e, n) { if (!(N.TYPED_ARRAY_SUPPORT || this instanceof N)) return new N(t, e, n); if ("number" == typeof t) { if ("string" == typeof e) throw new Error("If encoding is specified then the first argument must be a string"); return q(this, t) } return L(this, t, e, n) } function L(t, e, n, r) { if ("number" == typeof e) throw new TypeError('"value" argument must not be a number'); return "undefined" != typeof ArrayBuffer && e instanceof ArrayBuffer ? function (t, e, n, r) { if (e.byteLength, n < 0 || e.byteLength < n) throw new RangeError("'offset' is out of bounds"); if (e.byteLength < n + (r || 0)) throw new RangeError("'length' is out of bounds"); e = void 0 === n && void 0 === r ? new Uint8Array(e) : void 0 === r ? new Uint8Array(e, n) : new Uint8Array(e, n, r); N.TYPED_ARRAY_SUPPORT ? (t = e).__proto__ = N.prototype : t = Y(t, e); return t }(t, e, n, r) : "string" == typeof e ? function (t, e, n) { "string" == typeof n && "" !== n || (n = "utf8"); if (!N.isEncoding(n)) throw new TypeError('"encoding" must be a valid string encoding'); var r = 0 | W(e, n); t = j(t, r); var o = t.write(e, n); o !== r && (t = t.slice(0, o)); return t }(t, e, n) : function (t, e) { if (F(e)) { var n = 0 | M(e.length); return 0 === (t = j(t, n)).length || e.copy(t, 0, 0, n), t } if (e) { if ("undefined" != typeof ArrayBuffer && e.buffer instanceof ArrayBuffer || "length" in e) return "number" != typeof e.length || (r = e.length) != r ? j(t, 0) : Y(t, e); if ("Buffer" === e.type && $(e.data)) return Y(t, e.data) } var r; throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.") }(t, e) } function z(t) { if ("number" != typeof t) throw new TypeError('"size" argument must be a number'); if (t < 0) throw new RangeError('"size" argument must not be negative') } function q(t, e) { if (z(e), t = j(t, e < 0 ? 0 : 0 | M(e)), !N.TYPED_ARRAY_SUPPORT) for (var n = 0; n < e; ++n)t[n] = 0; return t } function Y(t, e) { var n = e.length < 0 ? 0 : 0 | M(e.length); t = j(t, n); for (var r = 0; r < n; r += 1)t[r] = 255 & e[r]; return t } function M(t) { if (t >= I()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + I().toString(16) + " bytes"); return 0 | t } function F(t) { return !(null == t || !t._isBuffer) } function W(t, e) { if (F(t)) return t.length; if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(t) || t instanceof ArrayBuffer)) return t.byteLength; "string" != typeof t && (t = "" + t); var n = t.length; if (0 === n) return 0; for (var r = !1; ;)switch (e) { case "ascii": case "latin1": case "binary": return n; case "utf8": case "utf-8": case void 0: return _t(t).length; case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return 2 * n; case "hex": return n >>> 1; case "base64": return yt(t).length; default: if (r) return _t(t).length; e = ("" + e).toLowerCase(), r = !0 } } function J(t, e, n) { var r = !1; if ((void 0 === e || e < 0) && (e = 0), e > this.length) return ""; if ((void 0 === n || n > this.length) && (n = this.length), n <= 0) return ""; if ((n >>>= 0) <= (e >>>= 0)) return ""; for (t || (t = "utf8"); ;)switch (t) { case "hex": return at(this, e, n); case "utf8": case "utf-8": return rt(this, e, n); case "ascii": return it(this, e, n); case "latin1": case "binary": return st(this, e, n); case "base64": return nt(this, e, n); case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return ut(this, e, n); default: if (r) throw new TypeError("Unknown encoding: " + t); t = (t + "").toLowerCase(), r = !0 } } function G(t, e, n) { var r = t[e]; t[e] = t[n], t[n] = r } function H(t, e, n, r, o) { if (0 === t.length) return -1; if ("string" == typeof n ? (r = n, n = 0) : n > 2147483647 ? n = 2147483647 : n < -2147483648 && (n = -2147483648), n = +n, isNaN(n) && (n = o ? 0 : t.length - 1), n < 0 && (n = t.length + n), n >= t.length) { if (o) return -1; n = t.length - 1 } else if (n < 0) { if (!o) return -1; n = 0 } if ("string" == typeof e && (e = N.from(e, r)), F(e)) return 0 === e.length ? -1 : V(t, e, n, r, o); if ("number" == typeof e) return e &= 255, N.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? o ? Uint8Array.prototype.indexOf.call(t, e, n) : Uint8Array.prototype.lastIndexOf.call(t, e, n) : V(t, [e], n, r, o); throw new TypeError("val must be string, number or Buffer") } function V(t, e, n, r, o) { var i, s = 1, a = t.length, u = e.length; if (void 0 !== r && ("ucs2" === (r = String(r).toLowerCase()) || "ucs-2" === r || "utf16le" === r || "utf-16le" === r)) { if (t.length < 2 || e.length < 2) return -1; s = 2, a /= 2, u /= 2, n /= 2 } function c(t, e) { return 1 === s ? t[e] : t.readUInt16BE(e * s) } if (o) { var h = -1; for (i = n; i < a; i++)if (c(t, i) === c(e, -1 === h ? 0 : i - h)) { if (-1 === h && (h = i), i - h + 1 === u) return h * s } else -1 !== h && (i -= i - h), h = -1 } else for (n + u > a && (n = a - u), i = n; i >= 0; i--) { for (var l = !0, f = 0; f < u; f++)if (c(t, i + f) !== c(e, f)) { l = !1; break } if (l) return i } return -1 } function Z(t, e, n, r) { n = Number(n) || 0; var o = t.length - n; r ? (r = Number(r)) > o && (r = o) : r = o; var i = e.length; if (i % 2 != 0) throw new TypeError("Invalid hex string"); r > i / 2 && (r = i / 2); for (var s = 0; s < r; ++s) { var a = parseInt(e.substr(2 * s, 2), 16); if (isNaN(a)) return s; t[n + s] = a } return s } function K(t, e, n, r) { return vt(_t(e, t.length - n), t, n, r) } function Q(t, e, n, r) { return vt(function (t) { for (var e = [], n = 0; n < t.length; ++n)e.push(255 & t.charCodeAt(n)); return e }(e), t, n, r) } function X(t, e, n, r) { return Q(t, e, n, r) } function tt(t, e, n, r) { return vt(yt(e), t, n, r) } function et(t, e, n, r) { return vt(function (t, e) { for (var n, r, o, i = [], s = 0; s < t.length && !((e -= 2) < 0); ++s)r = (n = t.charCodeAt(s)) >> 8, o = n % 256, i.push(o), i.push(r); return i }(e, t.length - n), t, n, r) } function nt(t, e, n) { return 0 === e && n === t.length ? O(t) : O(t.slice(e, n)) } function rt(t, e, n) { n = Math.min(t.length, n); for (var r = [], o = e; o < n;) { var i, s, a, u, c = t[o], h = null, l = c > 239 ? 4 : c > 223 ? 3 : c > 191 ? 2 : 1; if (o + l <= n) switch (l) { case 1: c < 128 && (h = c); break; case 2: 128 == (192 & (i = t[o + 1])) && (u = (31 & c) << 6 | 63 & i) > 127 && (h = u); break; case 3: i = t[o + 1], s = t[o + 2], 128 == (192 & i) && 128 == (192 & s) && (u = (15 & c) << 12 | (63 & i) << 6 | 63 & s) > 2047 && (u < 55296 || u > 57343) && (h = u); break; case 4: i = t[o + 1], s = t[o + 2], a = t[o + 3], 128 == (192 & i) && 128 == (192 & s) && 128 == (192 & a) && (u = (15 & c) << 18 | (63 & i) << 12 | (63 & s) << 6 | 63 & a) > 65535 && u < 1114112 && (h = u) }null === h ? (h = 65533, l = 1) : h > 65535 && (h -= 65536, r.push(h >>> 10 & 1023 | 55296), h = 56320 | 1023 & h), r.push(h), o += l } return function (t) { var e = t.length; if (e <= ot) return String.fromCharCode.apply(String, t); var n = "", r = 0; for (; r < e;)n += String.fromCharCode.apply(String, t.slice(r, r += ot)); return n }(r) } N.TYPED_ARRAY_SUPPORT = void 0 === t.TYPED_ARRAY_SUPPORT || t.TYPED_ARRAY_SUPPORT, I(), N.poolSize = 8192, N._augment = function (t) { return t.__proto__ = N.prototype, t }, N.from = function (t, e, n) { return L(null, t, e, n) }, N.TYPED_ARRAY_SUPPORT && (N.prototype.__proto__ = Uint8Array.prototype, N.__proto__ = Uint8Array, "undefined" != typeof Symbol && Symbol.species && N[Symbol.species]), N.alloc = function (t, e, n) { return function (t, e, n, r) { return z(e), e <= 0 ? j(t, e) : void 0 !== n ? "string" == typeof r ? j(t, e).fill(n, r) : j(t, e).fill(n) : j(t, e) }(null, t, e, n) }, N.allocUnsafe = function (t) { return q(null, t) }, N.allocUnsafeSlow = function (t) { return q(null, t) }, N.isBuffer = function (t) { return null != t && (!!t._isBuffer || bt(t) || function (t) { return "function" == typeof t.readFloatLE && "function" == typeof t.slice && bt(t.slice(0, 0)) }(t)) }, N.compare = function (t, e) { if (!F(t) || !F(e)) throw new TypeError("Arguments must be Buffers"); if (t === e) return 0; for (var n = t.length, r = e.length, o = 0, i = Math.min(n, r); o < i; ++o)if (t[o] !== e[o]) { n = t[o], r = e[o]; break } return n < r ? -1 : r < n ? 1 : 0 }, N.isEncoding = function (t) { switch (String(t).toLowerCase()) { case "hex": case "utf8": case "utf-8": case "ascii": case "latin1": case "binary": case "base64": case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return !0; default: return !1 } }, N.concat = function (t, e) { if (!$(t)) throw new TypeError('"list" argument must be an Array of Buffers'); if (0 === t.length) return N.alloc(0); var n; if (void 0 === e) for (e = 0, n = 0; n < t.length; ++n)e += t[n].length; var r = N.allocUnsafe(e), o = 0; for (n = 0; n < t.length; ++n) { var i = t[n]; if (!F(i)) throw new TypeError('"list" argument must be an Array of Buffers'); i.copy(r, o), o += i.length } return r }, N.byteLength = W, N.prototype._isBuffer = !0, N.prototype.swap16 = function () { var t = this.length; if (t % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits"); for (var e = 0; e < t; e += 2)G(this, e, e + 1); return this }, N.prototype.swap32 = function () { var t = this.length; if (t % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits"); for (var e = 0; e < t; e += 4)G(this, e, e + 3), G(this, e + 1, e + 2); return this }, N.prototype.swap64 = function () { var t = this.length; if (t % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits"); for (var e = 0; e < t; e += 8)G(this, e, e + 7), G(this, e + 1, e + 6), G(this, e + 2, e + 5), G(this, e + 3, e + 4); return this }, N.prototype.toString = function () { var t = 0 | this.length; return 0 === t ? "" : 0 === arguments.length ? rt(this, 0, t) : J.apply(this, arguments) }, N.prototype.equals = function (t) { if (!F(t)) throw new TypeError("Argument must be a Buffer"); return this === t || 0 === N.compare(this, t) }, N.prototype.inspect = function () { var t = ""; return this.length > 0 && (t = this.toString("hex", 0, 50).match(/.{2}/g).join(" "), this.length > 50 && (t += " ... ")), "<Buffer " + t + ">" }, N.prototype.compare = function (t, e, n, r, o) { if (!F(t)) throw new TypeError("Argument must be a Buffer"); if (void 0 === e && (e = 0), void 0 === n && (n = t ? t.length : 0), void 0 === r && (r = 0), void 0 === o && (o = this.length), e < 0 || n > t.length || r < 0 || o > this.length) throw new RangeError("out of range index"); if (r >= o && e >= n) return 0; if (r >= o) return -1; if (e >= n) return 1; if (this === t) return 0; for (var i = (o >>>= 0) - (r >>>= 0), s = (n >>>= 0) - (e >>>= 0), a = Math.min(i, s), u = this.slice(r, o), c = t.slice(e, n), h = 0; h < a; ++h)if (u[h] !== c[h]) { i = u[h], s = c[h]; break } return i < s ? -1 : s < i ? 1 : 0 }, N.prototype.includes = function (t, e, n) { return -1 !== this.indexOf(t, e, n) }, N.prototype.indexOf = function (t, e, n) { return H(this, t, e, n, !0) }, N.prototype.lastIndexOf = function (t, e, n) { return H(this, t, e, n, !1) }, N.prototype.write = function (t, e, n, r) { if (void 0 === e) r = "utf8", n = this.length, e = 0; else if (void 0 === n && "string" == typeof e) r = e, n = this.length, e = 0; else { if (!isFinite(e)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported"); e |= 0, isFinite(n) ? (n |= 0, void 0 === r && (r = "utf8")) : (r = n, n = void 0) } var o = this.length - e; if ((void 0 === n || n > o) && (n = o), t.length > 0 && (n < 0 || e < 0) || e > this.length) throw new RangeError("Attempt to write outside buffer bounds"); r || (r = "utf8"); for (var i = !1; ;)switch (r) { case "hex": return Z(this, t, e, n); case "utf8": case "utf-8": return K(this, t, e, n); case "ascii": return Q(this, t, e, n); case "latin1": case "binary": return X(this, t, e, n); case "base64": return tt(this, t, e, n); case "ucs2": case "ucs-2": case "utf16le": case "utf-16le": return et(this, t, e, n); default: if (i) throw new TypeError("Unknown encoding: " + r); r = ("" + r).toLowerCase(), i = !0 } }, N.prototype.toJSON = function () { return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) } }; var ot = 4096; function it(t, e, n) { var r = ""; n = Math.min(t.length, n); for (var o = e; o < n; ++o)r += String.fromCharCode(127 & t[o]); return r } function st(t, e, n) { var r = ""; n = Math.min(t.length, n); for (var o = e; o < n; ++o)r += String.fromCharCode(t[o]); return r } function at(t, e, n) { var r = t.length; (!e || e < 0) && (e = 0), (!n || n < 0 || n > r) && (n = r); for (var o = "", i = e; i < n; ++i)o += mt(t[i]); return o } function ut(t, e, n) { for (var r = t.slice(e, n), o = "", i = 0; i < r.length; i += 2)o += String.fromCharCode(r[i] + 256 * r[i + 1]); return o } function ct(t, e, n) { if (t % 1 != 0 || t < 0) throw new RangeError("offset is not uint"); if (t + e > n) throw new RangeError("Trying to access beyond buffer length") } function ht(t, e, n, r, o, i) { if (!F(t)) throw new TypeError('"buffer" argument must be a Buffer instance'); if (e > o || e < i) throw new RangeError('"value" argument is out of bounds'); if (n + r > t.length) throw new RangeError("Index out of range") } function lt(t, e, n, r) { e < 0 && (e = 65535 + e + 1); for (var o = 0, i = Math.min(t.length - n, 2); o < i; ++o)t[n + o] = (e & 255 << 8 * (r ? o : 1 - o)) >>> 8 * (r ? o : 1 - o) } function ft(t, e, n, r) { e < 0 && (e = 4294967295 + e + 1); for (var o = 0, i = Math.min(t.length - n, 4); o < i; ++o)t[n + o] = e >>> 8 * (r ? o : 3 - o) & 255 } function pt(t, e, n, r, o, i) { if (n + r > t.length) throw new RangeError("Index out of range"); if (n < 0) throw new RangeError("Index out of range") } function dt(t, e, n, r, o) { return o || pt(t, 0, n, 4), C(t, e, n, r, 23, 4), n + 4 } function gt(t, e, n, r, o) { return o || pt(t, 0, n, 8), C(t, e, n, r, 52, 8), n + 8 } N.prototype.slice = function (t, e) { var n, r = this.length; if ((t = ~~t) < 0 ? (t += r) < 0 && (t = 0) : t > r && (t = r), (e = void 0 === e ? r : ~~e) < 0 ? (e += r) < 0 && (e = 0) : e > r && (e = r), e < t && (e = t), N.TYPED_ARRAY_SUPPORT) (n = this.subarray(t, e)).__proto__ = N.prototype; else { var o = e - t; n = new N(o, void 0); for (var i = 0; i < o; ++i)n[i] = this[i + t] } return n }, N.prototype.readUIntLE = function (t, e, n) { t |= 0, e |= 0, n || ct(t, e, this.length); for (var r = this[t], o = 1, i = 0; ++i < e && (o *= 256);)r += this[t + i] * o; return r }, N.prototype.readUIntBE = function (t, e, n) { t |= 0, e |= 0, n || ct(t, e, this.length); for (var r = this[t + --e], o = 1; e > 0 && (o *= 256);)r += this[t + --e] * o; return r }, N.prototype.readUInt8 = function (t, e) { return e || ct(t, 1, this.length), this[t] }, N.prototype.readUInt16LE = function (t, e) { return e || ct(t, 2, this.length), this[t] | this[t + 1] << 8 }, N.prototype.readUInt16BE = function (t, e) { return e || ct(t, 2, this.length), this[t] << 8 | this[t + 1] }, N.prototype.readUInt32LE = function (t, e) { return e || ct(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + 16777216 * this[t + 3] }, N.prototype.readUInt32BE = function (t, e) { return e || ct(t, 4, this.length), 16777216 * this[t] + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]) }, N.prototype.readIntLE = function (t, e, n) { t |= 0, e |= 0, n || ct(t, e, this.length); for (var r = this[t], o = 1, i = 0; ++i < e && (o *= 256);)r += this[t + i] * o; return r >= (o *= 128) && (r -= Math.pow(2, 8 * e)), r }, N.prototype.readIntBE = function (t, e, n) { t |= 0, e |= 0, n || ct(t, e, this.length); for (var r = e, o = 1, i = this[t + --r]; r > 0 && (o *= 256);)i += this[t + --r] * o; return i >= (o *= 128) && (i -= Math.pow(2, 8 * e)), i }, N.prototype.readInt8 = function (t, e) { return e || ct(t, 1, this.length), 128 & this[t] ? -1 * (255 - this[t] + 1) : this[t] }, N.prototype.readInt16LE = function (t, e) { e || ct(t, 2, this.length); var n = this[t] | this[t + 1] << 8; return 32768 & n ? 4294901760 | n : n }, N.prototype.readInt16BE = function (t, e) { e || ct(t, 2, this.length); var n = this[t + 1] | this[t] << 8; return 32768 & n ? 4294901760 | n : n }, N.prototype.readInt32LE = function (t, e) { return e || ct(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24 }, N.prototype.readInt32BE = function (t, e) { return e || ct(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3] }, N.prototype.readFloatLE = function (t, e) { return e || ct(t, 4, this.length), B(this, t, !0, 23, 4) }, N.prototype.readFloatBE = function (t, e) { return e || ct(t, 4, this.length), B(this, t, !1, 23, 4) }, N.prototype.readDoubleLE = function (t, e) { return e || ct(t, 8, this.length), B(this, t, !0, 52, 8) }, N.prototype.readDoubleBE = function (t, e) { return e || ct(t, 8, this.length), B(this, t, !1, 52, 8) }, N.prototype.writeUIntLE = function (t, e, n, r) { (t = +t, e |= 0, n |= 0, r) || ht(this, t, e, n, Math.pow(2, 8 * n) - 1, 0); var o = 1, i = 0; for (this[e] = 255 & t; ++i < n && (o *= 256);)this[e + i] = t / o & 255; return e + n }, N.prototype.writeUIntBE = function (t, e, n, r) { (t = +t, e |= 0, n |= 0, r) || ht(this, t, e, n, Math.pow(2, 8 * n) - 1, 0); var o = n - 1, i = 1; for (this[e + o] = 255 & t; --o >= 0 && (i *= 256);)this[e + o] = t / i & 255; return e + n }, N.prototype.writeUInt8 = function (t, e, n) { return t = +t, e |= 0, n || ht(this, t, e, 1, 255, 0), N.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), this[e] = 255 & t, e + 1 }, N.prototype.writeUInt16LE = function (t, e, n) { return t = +t, e |= 0, n || ht(this, t, e, 2, 65535, 0), N.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t, this[e + 1] = t >>> 8) : lt(this, t, e, !0), e + 2 }, N.prototype.writeUInt16BE = function (t, e, n) { return t = +t, e |= 0, n || ht(this, t, e, 2, 65535, 0), N.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 8, this[e + 1] = 255 & t) : lt(this, t, e, !1), e + 2 }, N.prototype.writeUInt32LE = function (t, e, n) { return t = +t, e |= 0, n || ht(this, t, e, 4, 4294967295, 0), N.TYPED_ARRAY_SUPPORT ? (this[e + 3] = t >>> 24, this[e + 2] = t >>> 16, this[e + 1] = t >>> 8, this[e] = 255 & t) : ft(this, t, e, !0), e + 4 }, N.prototype.writeUInt32BE = function (t, e, n) { return t = +t, e |= 0, n || ht(this, t, e, 4, 4294967295, 0), N.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 24, this[e + 1] = t >>> 16, this[e + 2] = t >>> 8, this[e + 3] = 255 & t) : ft(this, t, e, !1), e + 4 }, N.prototype.writeIntLE = function (t, e, n, r) { if (t = +t, e |= 0, !r) { var o = Math.pow(2, 8 * n - 1); ht(this, t, e, n, o - 1, -o) } var i = 0, s = 1, a = 0; for (this[e] = 255 & t; ++i < n && (s *= 256);)t < 0 && 0 === a && 0 !== this[e + i - 1] && (a = 1), this[e + i] = (t / s >> 0) - a & 255; return e + n }, N.prototype.writeIntBE = function (t, e, n, r) { if (t = +t, e |= 0, !r) { var o = Math.pow(2, 8 * n - 1); ht(this, t, e, n, o - 1, -o) } var i = n - 1, s = 1, a = 0; for (this[e + i] = 255 & t; --i >= 0 && (s *= 256);)t < 0 && 0 === a && 0 !== this[e + i + 1] && (a = 1), this[e + i] = (t / s >> 0) - a & 255; return e + n }, N.prototype.writeInt8 = function (t, e, n) { return t = +t, e |= 0, n || ht(this, t, e, 1, 127, -128), N.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), t < 0 && (t = 255 + t + 1), this[e] = 255 & t, e + 1 }, N.prototype.writeInt16LE = function (t, e, n) { return t = +t, e |= 0, n || ht(this, t, e, 2, 32767, -32768), N.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t, this[e + 1] = t >>> 8) : lt(this, t, e, !0), e + 2 }, N.prototype.writeInt16BE = function (t, e, n) { return t = +t, e |= 0, n || ht(this, t, e, 2, 32767, -32768), N.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 8, this[e + 1] = 255 & t) : lt(this, t, e, !1), e + 2 }, N.prototype.writeInt32LE = function (t, e, n) { return t = +t, e |= 0, n || ht(this, t, e, 4, 2147483647, -2147483648), N.TYPED_ARRAY_SUPPORT ? (this[e] = 255 & t, this[e + 1] = t >>> 8, this[e + 2] = t >>> 16, this[e + 3] = t >>> 24) : ft(this, t, e, !0), e + 4 }, N.prototype.writeInt32BE = function (t, e, n) { return t = +t, e |= 0, n || ht(this, t, e, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), N.TYPED_ARRAY_SUPPORT ? (this[e] = t >>> 24, this[e + 1] = t >>> 16, this[e + 2] = t >>> 8, this[e + 3] = 255 & t) : ft(this, t, e, !1), e + 4 }, N.prototype.writeFloatLE = function (t, e, n) { return dt(this, t, e, !0, n) }, N.prototype.writeFloatBE = function (t, e, n) { return dt(this, t, e, !1, n) }, N.prototype.writeDoubleLE = function (t, e, n) { return gt(this, t, e, !0, n) }, N.prototype.writeDoubleBE = function (t, e, n) { return gt(this, t, e, !1, n) }, N.prototype.copy = function (t, e, n, r) { if (n || (n = 0), r || 0 === r || (r = this.length), e >= t.length && (e = t.length), e || (e = 0), r > 0 && r < n && (r = n), r === n) return 0; if (0 === t.length || 0 === this.length) return 0; if (e < 0) throw new RangeError("targetStart out of bounds"); if (n < 0 || n >= this.length) throw new RangeError("sourceStart out of bounds"); if (r < 0) throw new RangeError("sourceEnd out of bounds"); r > this.length && (r = this.length), t.length - e < r - n && (r = t.length - e + n); var o, i = r - n; if (this === t && n < e && e < r) for (o = i - 1; o >= 0; --o)t[o + e] = this[o + n]; else if (i < 1e3 || !N.TYPED_ARRAY_SUPPORT) for (o = 0; o < i; ++o)t[o + e] = this[o + n]; else Uint8Array.prototype.set.call(t, this.subarray(n, n + i), e); return i }, N.prototype.fill = function (t, e, n, r) { if ("string" == typeof t) { if ("string" == typeof e ? (r = e, e = 0, n = this.length) : "string" == typeof n && (r = n, n = this.length), 1 === t.length) { var o = t.charCodeAt(0); o < 256 && (t = o) } if (void 0 !== r && "string" != typeof r) throw new TypeError("encoding must be a string"); if ("string" == typeof r && !N.isEncoding(r)) throw new TypeError("Unknown encoding: " + r) } else "number" == typeof t && (t &= 255); if (e < 0 || this.length < e || this.length < n) throw new RangeError("Out of range index"); if (n <= e) return this; var i; if (e >>>= 0, n = void 0 === n ? this.length : n >>> 0, t || (t = 0), "number" == typeof t) for (i = e; i < n; ++i)this[i] = t; else { var s = F(t) ? t : _t(new N(t, r).toString()), a = s.length; for (i = 0; i < n - e; ++i)this[i + e] = s[i % a] } return this }; var wt = /[^+\/0-9A-Za-z-_]/g; function mt(t) { return t < 16 ? "0" + t.toString(16) : t.toString(16) } function _t(t, e) { var n; e = e || 1 / 0; for (var r = t.length, o = null, i = [], s = 0; s < r; ++s) { if ((n = t.charCodeAt(s)) > 55295 && n < 57344) { if (!o) { if (n > 56319) { (e -= 3) > -1 && i.push(239, 191, 189); continue } if (s + 1 === r) { (e -= 3) > -1 && i.push(239, 191, 189); continue } o = n; continue } if (n < 56320) { (e -= 3) > -1 && i.push(239, 191, 189), o = n; continue } n = 65536 + (o - 55296 << 10 | n - 56320) } else o && (e -= 3) > -1 && i.push(239, 191, 189); if (o = null, n < 128) { if ((e -= 1) < 0) break; i.push(n) } else if (n < 2048) { if ((e -= 2) < 0) break; i.push(n >> 6 | 192, 63 & n | 128) } else if (n < 65536) { if ((e -= 3) < 0) break; i.push(n >> 12 | 224, n >> 6 & 63 | 128, 63 & n | 128) } else { if (!(n < 1114112)) throw new Error("Invalid code point"); if ((e -= 4) < 0) break; i.push(n >> 18 | 240, n >> 12 & 63 | 128, n >> 6 & 63 | 128, 63 & n | 128) } } return i } function yt(t) { return function (t) { var e, n, r, o, i, s; k || x(); var a = t.length; if (a % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4"); i = "=" === t[a - 2] ? 2 : "=" === t[a - 1] ? 1 : 0, s = new R(3 * a / 4 - i), r = i > 0 ? a - 4 : a; var u = 0; for (e = 0, n = 0; e < r; e += 4, n += 3)o = P[t.charCodeAt(e)] << 18 | P[t.charCodeAt(e + 1)] << 12 | P[t.charCodeAt(e + 2)] << 6 | P[t.charCodeAt(e + 3)], s[u++] = o >> 16 & 255, s[u++] = o >> 8 & 255, s[u++] = 255 & o; return 2 === i ? (o = P[t.charCodeAt(e)] << 2 | P[t.charCodeAt(e + 1)] >> 4, s[u++] = 255 & o) : 1 === i && (o = P[t.charCodeAt(e)] << 10 | P[t.charCodeAt(e + 1)] << 4 | P[t.charCodeAt(e + 2)] >> 2, s[u++] = o >> 8 & 255, s[u++] = 255 & o), s }(function (t) { if ((t = function (t) { return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "") }(t).replace(wt, "")).length < 2) return ""; for (; t.length % 4 != 0;)t += "="; return t }(t)) } function vt(t, e, n, r) { for (var o = 0; o < r && !(o + n >= e.length || o >= t.length); ++o)e[o + n] = t[o]; return o } function bt(t) { return !!t.constructor && "function" == typeof t.constructor.isBuffer && t.constructor.isBuffer(t) } var Et, St = Object.defineProperty, At = (t, e, n) => (((t, e, n) => { e in t ? St(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n })(t, "symbol" != typeof e ? e + "" : e, n), n), Tt = (t, e, n) => { if (!e.has(t)) throw TypeError("Cannot " + n) }, Pt = (t, e, n) => (Tt(t, e, "read from private field"), n ? n.call(t) : e.get(t)), Rt = new Intl.Collator(0, { numeric: 1 }).compare; function kt(t, e, n) { return t = t.split("."), e = e.split("."), Rt(t[0], e[0]) || Rt(t[1], e[1]) || (e[2] = e.slice(2).join("."), (n = /[.-]/.test(t[2] = t.slice(2).join("."))) == /[.-]/.test(e[2]) ? Rt(t[2], e[2]) : n ? -1 : 1) } const xt = "host", Ut = "upload", Ot = "login", Bt = "runtime", Ct = "sleeptime", Dt = "This application is currently busy. Please try again. ", $t = "Connection errored out. ", It = "Could not resolve app config. ", jt = "Space metadata could not be loaded. ", Nt = "Invalid credentials. Could not login. ", Lt = "File system access is only available in Node.js environments", zt = "Root URL not found in client config", qt = "Error uploading file"; function Yt(t, e, n) { return e.startsWith("http://") || e.startsWith("https://") ? n ? t : e : t + e } async function Mt(t, e, n) { try { const r = await fetch(`https://huggingface.co/api/spaces/${t}/jwt`, { headers: { Authorization: `Bearer ${e}`, ...n ? { Cookie: n } : {} } }); return (await r.json()).token || !1 } catch (t) { return !1 } } async function Ft(t) { var e; const n = this.options.hf_token ? { Authorization: `Bearer ${this.options.hf_token}` } : {}; if (n["Content-Type"] = "application/json", "undefined" != typeof window && window.gradio_config && "http://localhost:9876" !== location.origin && !window.gradio_config.dev_mode) { const e = window.gradio_config.root, n = window.gradio_config; let r = Yt(t, n.root, !1); return n.root = r, { ...n, path: e } } if (t) { const r = Qt(t, "config"), o = await this.fetch(r, { headers: n, credentials: "include" }); if (401 === (null == o ? void 0 : o.status) && !this.options.auth) throw new Error("Login credentials are required to access this space."); if (401 === (null == o ? void 0 : o.status) && this.options.auth) throw new Error(Nt); if (200 === (null == o ? void 0 : o.status)) { let n = await o.json(); return n.path = n.path ?? "", n.root = t, null == (e = n.dependencies) || e.forEach(((t, e) => { void 0 === t.id && (t.id = e) })), n } if (401 === (null == o ? void 0 : o.status)) throw new Error("Not authorized to access this space. "); throw new Error(It) } throw new Error(It) } async function Wt() { const { http_protocol: t, host: e } = await Kt(this.app_reference, this.options.hf_token); try { if (this.options.auth) { const n = await Jt(t, e, this.options.auth, this.fetch, this.options.hf_token); n && this.set_cookies(n) } } catch (t) { throw Error(t.message) } } async function Jt(t, e, n, r, o) { const i = new FormData; i.append("username", null == n ? void 0 : n[0]), i.append("password", null == n ? void 0 : n[1]); let s = {}; o && (s.Authorization = `Bearer ${o}`); const a = await r(`${t}//${e}/${Ot}`, { headers: s, method: "POST", body: i, credentials: "include" }); if (200 === a.status) return a.headers.get("set-cookie"); throw 401 === a.status ? new Error(Nt) : new Error(jt) } function Gt(t) { if (t.startsWith("http")) { const { protocol: e, host: n, pathname: r } = new URL(t); return n.endsWith("hf.space") ? { ws_protocol: "wss", host: n, http_protocol: e } : { ws_protocol: "https:" === e ? "wss" : "ws", http_protocol: e, host: n + ("/" !== r ? r : "") } } return t.startsWith("file:") ? { ws_protocol: "ws", http_protocol: "http:", host: "lite.local" } : { ws_protocol: "wss", http_protocol: "https:", host: t } } const Ht = t => { let e = []; return t.split(/,(?=\s*[^\s=;]+=[^\s=;]+)/).forEach((t => { const [n, r] = t.split(";")[0].split("="); n && r && e.push(`${n.trim()}=${r.trim()}`) })), e }, Vt = /^[a-zA-Z0-9_\-\.]+\/[a-zA-Z0-9_\-\.]+$/, Zt = /.*hf\.space\/{0,1}$/; async function Kt(t, e) { const n = {}; e && (n.Authorization = `Bearer ${e}`); const r = t.trim().replace(/\/$/, ""); if (Vt.test(r)) try { const e = await fetch(`https://huggingface.co/api/spaces/${r}/${xt}`, { headers: n }); return { space_id: t, ...Gt((await e.json()).host) } } catch (t) { throw new Error(jt) } if (Zt.test(r)) { const { ws_protocol: t, http_protocol: e, host: n } = Gt(r); return { space_id: n.replace(".hf.space", ""), ws_protocol: t, http_protocol: e, host: n } } return { space_id: !1, ...Gt(r) } } const Qt = (...t) => { try { return t.reduce(((t, e) => (t = t.replace(/\/+$/, ""), e = e.replace(/^\/+/, ""), new URL(e, t + "/").toString()))) } catch (t) { throw new Error("Invalid URL. A full URL path is required.") } }; function Xt(t, e, n, r) { switch (null == t ? void 0 : t.type) { case "string": return "string"; case "boolean": return "boolean"; case "number": return "number" }return "JSONSerializable" === n || "StringSerializable" === n ? "any" : "ListStringSerializable" === n ? "string[]" : "Image" === e ? "parameter" === r ? "Blob | File | Buffer" : "string" : "FileSerializable" === n ? "array" === (null == t ? void 0 : t.type) ? "parameter" === r ? "(Blob | File | Buffer)[]" : "{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}[]" : "parameter" === r ? "Blob | File | Buffer" : "{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}" : "GallerySerializable" === n ? "parameter" === r ? "[(Blob | File | Buffer), (string | null)][]" : "[{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}, (string | null))][]" : void 0 } function te(t, e) { return "GallerySerializable" === e ? "array of [file, label] tuples" : "ListStringSerializable" === e ? "array of strings" : "FileSerializable" === e ? "array of files or single file" : null == t ? void 0 : t.description } function ee(t, e) { const n = !0; switch (t.msg) { case "send_data": return { type: "data" }; case "send_hash": return { type: "hash" }; case "queue_full": return { type: "update", status: { queue: n, message: Dt, stage: "error", code: t.code, success: t.success } }; case "heartbeat": return { type: "heartbeat" }; case "unexpected_error": return { type: "unexpected_error", status: { queue: n, message: t.message, stage: "error", success: !1 } }; case "estimation": return { type: "update", status: { queue: n, stage: e || "pending", code: t.code, size: t.queue_size, position: t.rank, eta: t.rank_eta, success: t.success } }; case "progress": return { type: "update", status: { queue: n, stage: "pending", code: t.code, progress_data: t.progress_data, success: t.success } }; case "log": return { type: "log", data: t }; case "process_generating": return { type: "generating", status: { queue: n, message: t.success ? null : t.output.error, stage: t.success ? "generating" : "error", code: t.code, progress_data: t.progress_data, eta: t.average_duration }, data: t.success ? t.output : null }; case "process_completed": return "error" in t.output ? { type: "update", status: { queue: n, message: t.output.error, stage: "error", code: t.code, success: t.success } } : { type: "complete", status: { queue: n, message: t.success ? void 0 : t.output.error, stage: t.success ? "complete" : "error", code: t.code, progress_data: t.progress_data, changed_state_ids: t.success ? t.output.changed_state_ids : void 0 }, data: t.success ? t.output : null }; case "process_starts": return { type: "update", status: { queue: n, stage: "pending", code: t.code, size: t.rank, position: 0, success: t.success, eta: t.eta } } }return { type: "none", status: { stage: "error", queue: n } } } async function ne() { if (this.api_info) return this.api_info; const { hf_token: t } = this.options, { config: e } = this, n = { "Content-Type": "application/json" }; if (t && (n.Authorization = `Bearer ${t}`), e) try { let t; if (kt((null == e ? void 0 : e.version) || "2.0.0", "3.30") < 0) t = await this.fetch("https://gradio-space-api-fetcher-v2.hf.space/api", { method: "POST", body: JSON.stringify({ serialize: !1, config: JSON.stringify(e) }), headers: n, credentials: "include" }); else { const r = Qt(e.root, "info"); t = await this.fetch(r, { headers: n, credentials: "include" }) } if (!t.ok) throw new Error($t); let r = await t.json(); return "api" in r && (r = r.api), r.named_endpoints["/predict"] && !r.unnamed_endpoints[0] && (r.unnamed_endpoints[0] = r.named_endpoints["/predict"]), function (t, e, n) { const r = { named_endpoints: {}, unnamed_endpoints: {} }; return Object.keys(t).forEach((o => { "named_endpoints" !== o && "unnamed_endpoints" !== o || (r[o] = {}, Object.entries(t[o]).forEach((([t, { parameters: i, returns: s }]) => { var a, u, c, h; const l = (null == (a = e.dependencies.find((e => e.api_name === t || e.api_name === t.replace("/", "")))) ? void 0 : a.id) || n[t.replace("/", "")] || -1, f = -1 !== l ? null == (u = e.dependencies.find((t => t.id == l))) ? void 0 : u.types : { continuous: !1, generator: !1, cancel: !1 }; if (-1 !== l && (null == (h = null == (c = e.dependencies.find((t => t.id == l))) ? void 0 : c.inputs) ? void 0 : h.length) !== i.length) { const t = e.dependencies.find((t => t.id == l)).inputs.map((t => { var n; return null == (n = e.components.find((e => e.id === t))) ? void 0 : n.type })); try { t.forEach(((t, e) => { if ("state" === t) { const t = { component: "state", example: null, parameter_default: null, parameter_has_default: !0, parameter_name: null, hidden: !0 }; i.splice(e, 0, t) } })) } catch (t) { console.error(t) } } const p = (t, e, n, r) => ({ ...t, description: te(null == t ? void 0 : t.type, n), type: Xt(null == t ? void 0 : t.type, e, n, r) || "" }); r[o][t] = { parameters: i.map((t => p(t, null == t ? void 0 : t.component, null == t ? void 0 : t.serializer, "parameter"))), returns: s.map((t => p(t, null == t ? void 0 : t.component, null == t ? void 0 : t.serializer, "return"))), type: f } }))) })), r }(r, e, this.api_map) } catch (t) { t.message } } async function re(t, e, n) { var r; const o = {}; (null == (r = null == this ? void 0 : this.options) ? void 0 : r.hf_token) && (o.Authorization = `Bearer ${this.options.hf_token}`); const i = []; let s; for (let r = 0; r < e.length; r += 1e3) { const a = e.slice(r, r + 1e3), u = new FormData; a.forEach((t => { u.append("files", t) })); try { const e = n ? `${t}/${Ut}?upload_id=${n}` : `${t}/${Ut}`; s = await this.fetch(e, { method: "POST", body: u, headers: o, credentials: "include" }) } catch (t) { throw new Error($t + t.message) } if (!s.ok) { const t = await s.text(); return { error: `HTTP ${s.status}: ${t}` } } const c = await s.json(); c && i.push(...c) } return { files: i } } async function oe(t, e, n, r) { let o = (Array.isArray(t) ? t : [t]).map((t => t.blob)); const i = o.filter((t => t.size > (r ?? 1 / 0))); if (i.length) throw new Error(`File size exceeds the maximum allowed size of ${r} bytes: ${i.map((t => t.name)).join(", ")}`); return await Promise.all(await this.upload_files(e, o, n).then((async n => { if (n.error) throw new Error(n.error); return n.files ? n.files.map(((n, r) => new se({ ...t[r], path: n, url: e + "/file=" + n }))) : [] }))) } async function ie(t, e) { return t.map((t => new se({ path: t.name, orig_name: t.name, blob: t, size: t.size, mime_type: t.type, is_stream: e }))) } class se { constructor({ path: t, url: e, orig_name: n, size: r, blob: o, is_stream: i, mime_type: s, alt_text: a }) { At(this, "path"), At(this, "url"), At(this, "orig_name"), At(this, "size"), At(this, "blob"), At(this, "is_stream"), At(this, "mime_type"), At(this, "alt_text"), At(this, "meta", { _type: "gradio.FileData" }), this.path = t, this.url = e, this.orig_name = n, this.size = r, this.blob = e ? void 0 : o, this.is_stream = i, this.mime_type = s, this.alt_text = a } } class ae { constructor(t, e) { At(this, "type"), At(this, "command"), At(this, "meta"), At(this, "fileData"), this.type = "command", this.command = t, this.meta = e } } const ue = void 0 !== A && A.versions && A.versions.node; function ce(t, e, n) { for (; n.length > 1;) { const e = n.shift(); if ("string" != typeof e && "number" != typeof e) throw new Error("Invalid key type"); t = t[e] } const r = n.shift(); if ("string" != typeof r && "number" != typeof r) throw new Error("Invalid key type"); t[r] = e } async function he(t, e = void 0, n = [], r = !1, o = void 0) { if (Array.isArray(t)) { let i = []; return await Promise.all(t.map((async (s, a) => { var u; let c = n.slice(); c.push(String(a)); const h = await he(t[a], r ? (null == (u = null == o ? void 0 : o.parameters[a]) ? void 0 : u.component) || void 0 : e, c, !1, o); i = i.concat(h) }))), i } if (globalThis.Buffer && t instanceof globalThis.Buffer || t instanceof Blob) return [{ path: n, blob: new Blob([t]), type: e }]; if ("object" == typeof t && null !== t) { let e = []; for (const r of Object.keys(t)) { const i = [...n, r], s = t[r]; e = e.concat(await he(s, void 0, i, !1, o)) } return e } return [] } function le(t) { if ("string" == typeof t) { if (t.startsWith("http://") || t.startsWith("https://")) return { path: t, url: t, orig_name: t.split("/").pop() ?? "unknown", meta: { _type: "gradio.FileData" } }; if (ue) return new ae("upload_file", { path: t, name: t, orig_path: t }) } else { if ("undefined" != typeof File && t instanceof File) return { path: t instanceof File ? t.name : "blob", orig_name: t instanceof File ? t.name : "unknown", blob: t instanceof File ? t : new Blob([t]), size: t instanceof Blob ? t.size : N.byteLength(t), mime_type: t instanceof File ? t.type : "application/octet-stream", meta: { _type: "gradio.FileData" } }; if (t instanceof N) return new Blob([t]); if (t instanceof Blob) return t } throw new Error("Invalid input: must be a URL, File, Blob, or Buffer object.") } function fe(t, e, n, r, o = !1) { if ("input" === r && !o) throw new Error("Invalid code path. Cannot skip state inputs for input."); if ("output" === r && o) return t; let i = [], s = 0; for (let r = 0; r < e.inputs.length; r++) { const a = e.inputs[r], u = n.find((t => t.id === a)); if ("state" !== (null == u ? void 0 : u.type)) { const e = t[s]; i.push(e), s++ } else { if (!o) { s++; continue } if (t.length === e.inputs.length) { const e = t[s]; i.push(e), s++ } else i.push(null) } } return i } async function pe(t, e, n) { const r = this; await async function (t, e) { var n, r; if (!(null == (n = t.config) ? void 0 : n.root) && !(null == (r = t.config) ? void 0 : r.root_url)) throw new Error(zt); await de(t, e) }(r, e); const o = await he(e, void 0, [], !0, n); return (await Promise.all(o.map((async ({ path: e, blob: n, type: o }) => { if (!n) return { path: e, type: o }; const i = await r.upload_files(t, [n]); return { path: e, file_url: i.files && i.files[0], type: o, name: n instanceof File ? null == n ? void 0 : n.name : void 0 } })))).forEach((({ path: t, file_url: n, type: r, name: o }) => { if ("Gallery" === r) ce(e, n, t); else if (n) { const r = new se({ path: n, orig_name: o }); ce(e, r, t) } })), e } async function de(t, e, n = []) { for (const r in e) e[r] instanceof ae ? await ge(t, e, r) : "object" == typeof e[r] && null !== e[r] && await de(t, e[r], [...n, r]) } async function ge(t, e, n) { var r, o; let i = e[n]; const s = (null == (r = t.config) ? void 0 : r.root) || (null == (o = t.config) ? void 0 : o.root_url); if (!s) throw new Error(zt); try { let r, o; if (void 0 === A || !A.versions || !A.versions.node) throw new Error(Lt); { const t = await import("/npm/fs/promises/+esm"); o = (await import("/npm/path/+esm")).resolve(A.cwd(), i.meta.path), r = await t.readFile(o) } const a = new Blob([r], { type: "application/octet-stream" }), u = await t.upload_files(s, [a]), c = u.files && u.files[0]; if (c) { const t = new se({ path: c, orig_name: i.meta.name || "" }); e[n] = t } } catch (t) { console.error(qt, t) } } async function we(t, e, n) { const r = { "Content-Type": "application/json" }; this.options.hf_token && (r.Authorization = `Bearer ${this.options.hf_token}`); try { var o = await this.fetch(t, { method: "POST", body: JSON.stringify(e), headers: { ...r, ...n }, credentials: "include" }) } catch (t) { return [{ error: $t }, 500] } let i, s; try { i = await o.json(), s = o.status } catch (t) { i = { error: `Could not parse server response: ${t}` }, s = 500 } return [i, s] } async function me(t, e) { let n, r = !1, o = !1; if (!this.config) throw new Error("Could not resolve app config"); if ("number" == typeof t) n = this.config.dependencies.find((e => e.id == t)); else { const e = t.replace(/^\//, ""); n = this.config.dependencies.find((t => t.id == this.api_map[e])) } if (null == n ? void 0 : n.types.continuous) throw new Error("Cannot call predict on this function as it may run forever. Use submit instead"); return new Promise((async (n, i) => { const s = this.submit(t, e, null, null, !0); let a; for await (const t of s) "data" === t.type && (o && n(a), r = !0, a = t), "status" === t.type && ("error" === t.stage && i(t), "complete" === t.stage && (o = !0, r && n(a))) })) } async function _e(t, e, n) { let r, o, i = "subdomain" === e ? `https://huggingface.co/api/spaces/by-subdomain/${t}` : `https://huggingface.co/api/spaces/${t}`; try { if (r = await fetch(i), o = r.status, 200 !== o) throw new Error; r = await r.json() } catch (t) { return void n({ status: "error", load_status: "error", message: "Could not get space status. ", detail: "NOT_FOUND" }) } if (!r || 200 !== o) return; const { runtime: { stage: s }, id: a } = r; switch (s) { case "STOPPED": case "SLEEPING": n({ status: "sleeping", load_status: "pending", message: "Space is asleep. Waking it up...", detail: s }), setTimeout((() => { _e(t, e, n) }), 1e3); break; case "PAUSED": n({ status: "paused", load_status: "error", message: "This space has been paused by the author. If you would like to try this demo, consider duplicating the space.", detail: s, discussions_enabled: await ve(a) }); break; case "RUNNING": case "RUNNING_BUILDING": n({ status: "running", load_status: "complete", message: "", detail: s }); break; case "BUILDING": n({ status: "building", load_status: "pending", message: "Space is building...", detail: s }), setTimeout((() => { _e(t, e, n) }), 1e3); break; default: n({ status: "space_error", load_status: "error", message: "This space is experiencing an issue.", detail: s, discussions_enabled: await ve(a) }) } } const ye = /^(?=[^]*\b[dD]iscussions{0,1}\b)(?=[^]*\b[dD]isabled\b)[^]*$/; async function ve(t) { try { const e = await fetch(`https://huggingface.co/api/spaces/${t}/discussions`, { method: "HEAD" }), n = e.headers.get("x-error-message"); return !(!e.ok || n && ye.test(n)) } catch (t) { return !1 } } const be = ["cpu-basic", "cpu-upgrade", "cpu-xl", "t4-small", "t4-medium", "a10g-small", "a10g-large", "a10g-largex2", "a10g-largex4", "a100-large", "zero-a10g", "h100", "h100x8"]; async function Ee(t, e) { const { hf_token: n, private: r, hardware: o, timeout: i, auth: s } = e; if (o && !be.includes(o)) throw new Error(`Invalid hardware type provided. Valid types are: ${be.map((t => `"${t}"`)).join(",")}.`); const { http_protocol: a, host: u } = await Kt(t, n); let c = null; if (s) { const t = await Jt(a, u, s, fetch); t && (c = Ht(t)) } const h = { Authorization: `Bearer ${n}`, "Content-Type": "application/json", ...c ? { Cookie: c.join("; ") } : {} }, l = (await (await fetch("https://huggingface.co/api/whoami-v2", { headers: h })).json()).name, f = t.split("/")[1], p = { repository: `${l}/${f}` }; let d; r && (p.private = !0); try { o || (d = await async function (t, e) { const n = {}; e && (n.Authorization = `Bearer ${e}`); try { const e = await fetch(`https://huggingface.co/api/spaces/${t}/${Bt}`, { headers: n }); if (200 !== e.status) throw new Error("Space hardware could not be obtained."); const { hardware: r } = await e.json(); return r.current } catch (t) { throw new Error(t.message) } }(t, n)) } catch (t) { throw Error(jt + t.message) } const g = o || d || "cpu-basic"; p.hardware = g; try { const r = await fetch(`https://huggingface.co/api/spaces/${t}/duplicate`, { method: "POST", headers: h, body: JSON.stringify(p) }); if (409 === r.status) try { return await Be.connect(`${l}/${f}`, e) } catch (t) { throw console.error("Failed to connect Client instance:", t), t } else if (200 !== r.status) throw new Error(r.statusText); const o = await r.json(); return await async function (t, e, n) { const r = {}; n && (r.Authorization = `Bearer ${n}`); const o = { seconds: e }; try { const e = await fetch(`https://huggingface.co/api/spaces/${t}/${Ct}`, { method: "POST", headers: { "Content-Type": "application/json", ...r }, body: JSON.stringify(o) }); if (200 !== e.status) throw new Error("Could not set sleep timeout on duplicated Space. Please visit *ADD HF LINK TO SETTINGS* to set a timeout manually to reduce billing charges."); return await e.json() } catch (t) { throw new Error(t.message) } }(`${l}/${f}`, i || 300, n), await Be.connect(function (t) { const e = /https:\/\/huggingface.co\/spaces\/([^/]+\/[^/]+)/, n = t.match(e); if (n) return n[1] }(o.url), e) } catch (t) { throw new Error(t) } } class Se extends TransformStream { constructor(t = { allowCR: !1 }) { super({ transform: (e, n) => { for (e = Pt(this, Et) + e; ;) { const r = e.indexOf("\n"), o = t.allowCR ? e.indexOf("\r") : -1; if (-1 !== o && o !== e.length - 1 && (-1 === r || r - 1 > o)) { n.enqueue(e.slice(0, o)), e = e.slice(o + 1); continue } if (-1 === r) break; const i = "\r" === e[r - 1] ? r - 1 : r; n.enqueue(e.slice(0, i)), e = e.slice(r + 1) } var r, o, i, s; i = e, Tt(r = this, o = Et, "write to private field"), s ? s.call(r, i) : o.set(r, i) }, flush: e => { if ("" === Pt(this, Et)) return; const n = t.allowCR && Pt(this, Et).endsWith("\r") ? Pt(this, Et).slice(0, -1) : Pt(this, Et); e.enqueue(n) } }), ((t, e, n) => { if (e.has(t)) throw TypeError("Cannot add the same private member more than once"); e instanceof WeakSet ? e.add(t) : e.set(t, n) })(this, Et, "") } } function Ae(t) { let e = /[:]\s*/.exec(t), n = e && e.index; if (n) return [t.substring(0, n), t.substring(n + e[0].length)] } function Te(t, e, n) { t.get(e) || t.set(e, n) } async function* Pe(t, e) { if (!t.body) return; let n, r, o = function (t) { let e = new TextDecoderStream, n = new Se({ allowCR: !0 }); return t.pipeThrough(e).pipeThrough(n) }(t.body).getReader(); for (; ;) { if (e && e.aborted) return o.cancel(); if (n = await o.read(), n.done) return; if (!n.value) { r && (yield r), r = void 0; continue } let [t, i] = Ae(n.value) || []; t && ("data" === t ? (r || (r = {}), r[t] = r[t] ? r[t] + "\n" + i : i) : "event" === t ? (r || (r = {}), r[t] = i) : "id" === t ? (r || (r = {}), r[t] = +i || i) : "retry" === t && (r || (r = {}), r[t] = +i || void 0)) } } async function Re() { let { event_callbacks: t, unclosed_events: e, pending_stream_messages: n, stream_status: r, config: o, jwt: i } = this; const s = this; if (!o) throw new Error("Could not resolve app config"); r.open = !0; let a = null, u = new URLSearchParams({ session_hash: this.session_hash }).toString(), c = new URL(`${o.root}/queue/data?${u}`); i && c.searchParams.set("__sign", i), a = this.stream(c), a ? (a.onmessage = async function (i) { let a = JSON.parse(i.data); if ("close_stream" === a.msg) return void ke(r, s.abort_controller); const u = a.event_id; if (u) if (t[u] && o) { "process_completed" === a.msg && ["sse", "sse_v1", "sse_v2", "sse_v2.1", "sse_v3"].includes(o.protocol) && e.delete(u); let n = t[u]; "undefined" != typeof window && "undefined" != typeof document ? setTimeout(n, 0, a) : n(a) } else n[u] || (n[u] = []), n[u].push(a); else await Promise.all(Object.keys(t).map((e => t[e](a)))) }, a.onerror = async function () { await Promise.all(Object.keys(t).map((e => t[e]({ msg: "unexpected_error", message: $t })))) }) : console.warn("Cannot connect to SSE endpoint: " + c.toString()) } function ke(t, e) { t && (t.open = !1, null == e || e.abort()) } function xe(t, e, n) { !t[e] ? (t[e] = [], n.data.forEach(((n, r) => { t[e][r] = n }))) : n.data.forEach(((r, o) => { let i = (s = t[e][o], r.forEach((([t, e, n]) => { s = function (t, e, n, r) { if (0 === e.length) { if ("replace" === n) return r; if ("append" === n) return t + r; throw new Error(`Unsupported action: ${n}`) } let o = t; for (let t = 0; t < e.length - 1; t++)o = o[e[t]]; const i = e[e.length - 1]; switch (n) { case "replace": o[i] = r; break; case "append": o[i] += r; break; case "add": Array.isArray(o) ? o.splice(Number(i), 0, r) : o[i] = r; break; case "delete": Array.isArray(o) ? o.splice(Number(i), 1) : delete o[i]; break; default: throw new Error(`Unknown action: ${n}`) }return t }(s, e, t, n) })), s); var s; t[e][o] = i, n.data[o] = i })) } function Ue(t, e = {}) { const n = { close: () => { throw new Error("Method not implemented.") }, onerror: null, onmessage: null, onopen: null, readyState: 0, url: t.toString(), withCredentials: !1, CONNECTING: 0, OPEN: 1, CLOSED: 2, addEventListener: () => { throw new Error("Method not implemented.") }, dispatchEvent: () => { throw new Error("Method not implemented.") }, removeEventListener: () => { throw new Error("Method not implemented.") } }; return async function (t, e) { let n = new Request(t, e); Te(n.headers, "Accept", "text/event-stream"), Te(n.headers, "Content-Type", "application/json"); let r = await fetch(n); if (!r.ok) throw r; return Pe(r, n.signal) }(t, e).then((async t => { n.readyState = n.OPEN; try { for await (const e of t) n.onmessage && n.onmessage(e); n.readyState = n.CLOSED } catch (t) { n.onerror && n.onerror(t), n.readyState = n.CLOSED } })).catch((t => { console.error(t), n.onerror && n.onerror(t), n.readyState = n.CLOSED })), n } function Oe(t, e, n, r, o) { var i; try { let a = function (t) { (o || q[t.type]) && l(t) }, u = function () { for (M = !0; W.length > 0;)W.shift()({ value: void 0, done: !0 }) }, c = function (t) { M || (W.length > 0 ? W.shift()(t) : F.push(t)) }, h = function (t) { c(function (t) { return { then: (e, n) => n(t) } }(t)), u() }, l = function (t) { c({ value: t, done: !1 }) }, f = function () { return F.length > 0 ? Promise.resolve(F.shift()) : M ? Promise.resolve({ value: void 0, done: !0 }) : new Promise((t => W.push(t))) }; const { hf_token: p } = this.options, { fetch: d, app_reference: g, config: w, session_hash: m, api_info: _, api_map: y, stream_status: v, pending_stream_messages: b, pending_diff_streams: E, event_callbacks: S, unclosed_events: A, post_data: T, options: P } = this, R = this; if (!_) throw new Error("No API found"); if (!w) throw new Error("Could not resolve app config"); let k, x, { fn_index: U, endpoint_info: O, dependency: B } = function (t, e, n, r) { let o, i, s; if ("number" == typeof e) o = e, i = t.unnamed_endpoints[o], s = r.dependencies.find((t => t.id == e)); else { const a = e.replace(/^\//, ""); o = n[a], i = t.named_endpoints[e.trim()], s = r.dependencies.find((t => t.id == n[a])) } if ("number" != typeof o) throw new Error("There is no endpoint matching that name of fn_index matching that number."); return { fn_index: o, endpoint_info: i, dependency: s } }(_, t, y, w), C = ((t, e) => { const n = Object.values(e.named_endpoints).flatMap((t => t.parameters)); if (Array.isArray(t)) return t.length > n.length && console.warn("Too many arguments provided for the endpoint."), t; const r = [], o = Object.keys(t); return n.forEach(((e, n) => { if (t.hasOwnProperty(e.parameter_name)) r[n] = t[e.parameter_name]; else { if (!e.parameter_has_default) throw new Error(`No value provided for required parameter: ${e.parameter_name}`); r[n] = e.parameter_default } })), o.forEach((t => { if (!n.some((e => e.parameter_name === t))) throw new Error(`Parameter \`${t}\` is not a valid keyword argument. Please refer to the API for usage.`) })), r.forEach(((t, e) => { if (void 0 === t && !n[e].parameter_has_default) throw new Error(`No value provided for required parameter: ${n[e].parameter_name}`) })), r })(e, _), D = w.protocol ?? "ws"; const $ = "number" == typeof t ? "/predict" : t; let I, j = null, N = !1, L = {}, z = "undefined" != typeof window && "undefined" != typeof document ? new URLSearchParams(window.location.search).toString() : ""; const q = (null == (i = null == P ? void 0 : P.events) ? void 0 : i.reduce(((t, e) => (t[e] = !0, t)), {})) || {}; const Y = async t => { await this._resolve_hearbeat(t) }; async function s(t) { if (!w) return; let e = t.render_id; w.components = [...w.components.filter((t => t.props.rendered_in !== e)), ...t.components], w.dependencies = [...w.dependencies.filter((t => t.rendered_in !== e)), ...t.dependencies]; const n = w.components.some((t => "state" === t.type)), r = w.dependencies.some((t => t.targets.some((t => "unload" === t[1])))); w.connect_heartbeat = n || r, await Y(w), a({ type: "render", data: t, endpoint: $, fn_index: U }) } this.handle_blob(w.root, C, O).then((async t => { var e; let o = fe(t, B, w.components, "input", !0); if (I = { data: o || [], event_data: n, fn_index: U, trigger_id: r }, function (t, e) { var n, r; let o = null == (r = null == (n = null == e ? void 0 : e.dependencies) ? void 0 : n.find((e => e.id == t))) ? void 0 : r.queue; return null != o ? !o : !e.enable_queue }(U, w)) a({ type: "status", endpoint: $, stage: "pending", queue: !1, fn_index: U, time: new Date }), T(`${w.root}/run${$.startsWith("/") ? $ : `/${$}`}${z ? "?" + z : ""}`, { ...I, session_hash: m }).then((([t, e]) => { const o = t.data; 200 == e ? (a({ type: "data", endpoint: $, fn_index: U, data: fe(o, B, w.components, "output", P.with_null_state), time: new Date, event_data: n, trigger_id: r }), t.render_config && s(t.render_config), a({ type: "status", endpoint: $, fn_index: U, stage: "complete", eta: t.average_duration, queue: !1, time: new Date })) : a({ type: "status", stage: "error", endpoint: $, fn_index: U, message: t.error, queue: !1, time: new Date }) })).catch((t => { a({ type: "status", stage: "error", message: t.message, endpoint: $, fn_index: U, queue: !1, time: new Date }) })); else if ("ws" == D) { const { ws_protocol: t, host: e } = await Kt(g, p); a({ type: "status", stage: "pending", queue: !0, endpoint: $, fn_index: U, time: new Date }); let o = new URL(`${t}://${Yt(e, w.path, !0)}/queue/join${z ? "?" + z : ""}`); this.jwt && o.searchParams.set("__sign", this.jwt), k = new WebSocket(o), k.onclose = t => { t.wasClean || a({ type: "status", stage: "error", broken: !0, message: $t, queue: !0, endpoint: $, fn_index: U, time: new Date }) }, k.onmessage = function (t) { const e = JSON.parse(t.data), { type: o, status: i, data: s } = ee(e, L[U]); if ("update" === o && i && !N) a({ type: "status", endpoint: $, fn_index: U, time: new Date, ...i }), "error" === i.stage && k.close(); else { if ("hash" === o) return void k.send(JSON.stringify({ fn_index: U, session_hash: m })); "data" === o ? k.send(JSON.stringify({ ...I, session_hash: m })) : "complete" === o ? N = i : "log" === o ? a({ type: "log", log: s.log, level: s.level, endpoint: $, fn_index: U }) : "generating" === o && a({ type: "status", time: new Date, ...i, stage: null == i ? void 0 : i.stage, queue: !0, endpoint: $, fn_index: U }) } s && (a({ type: "data", time: new Date, data: fe(s.data, B, w.components, "output", P.with_null_state), endpoint: $, fn_index: U, event_data: n, trigger_id: r }), N && (a({ type: "status", time: new Date, ...N, stage: null == i ? void 0 : i.stage, queue: !0, endpoint: $, fn_index: U }), k.close())) }, kt(w.version || "2.0.0", "3.6") < 0 && addEventListener("open", (() => k.send(JSON.stringify({ hash: m })))) } else if ("sse" == D) { a({ type: "status", stage: "pending", queue: !0, endpoint: $, fn_index: U, time: new Date }); var i = new URLSearchParams({ fn_index: U.toString(), session_hash: m }).toString(); let t = new URL(`${w.root}/queue/join?${z ? z + "&" : ""}${i}`); if (this.jwt && t.searchParams.set("__sign", this.jwt), x = this.stream(t), !x) return Promise.reject(new Error("Cannot connect to SSE endpoint: " + t.toString())); x.onmessage = async function (t) { const e = JSON.parse(t.data), { type: o, status: i, data: s } = ee(e, L[U]); if ("update" === o && i && !N) a({ type: "status", endpoint: $, fn_index: U, time: new Date, ...i }), "error" === i.stage && (null == x || x.close(), u()); else if ("data" === o) { j = e.event_id; let [t, n] = await T(`${w.root}/queue/data`, { ...I, session_hash: m, event_id: j }); 200 !== n && (a({ type: "status", stage: "error", message: $t, queue: !0, endpoint: $, fn_index: U, time: new Date }), null == x || x.close(), u()) } else "complete" === o ? N = i : "log" === o ? a({ type: "log", log: s.log, level: s.level, endpoint: $, fn_index: U }) : "generating" === o && a({ type: "status", time: new Date, ...i, stage: null == i ? void 0 : i.stage, queue: !0, endpoint: $, fn_index: U }); s && (a({ type: "data", time: new Date, data: fe(s.data, B, w.components, "output", P.with_null_state), endpoint: $, fn_index: U, event_data: n, trigger_id: r }), N && (a({ type: "status", time: new Date, ...N, stage: null == i ? void 0 : i.stage, queue: !0, endpoint: $, fn_index: U }), null == x || x.close(), u())) } } else if ("sse_v1" == D || "sse_v2" == D || "sse_v2.1" == D || "sse_v3" == D) { a({ type: "status", stage: "pending", queue: !0, endpoint: $, fn_index: U, time: new Date }); let t = ""; "undefined" != typeof window && "undefined" != typeof document && (t = null == (e = null == window ? void 0 : window.location) ? void 0 : e.hostname); let n = "dev.spaces.huggingface.tech"; const r = t.includes(".dev.") ? `https://moon-${t.split(".")[1]}.${n}` : "https://huggingface.co", o = "undefined" != typeof window && "undefined" != typeof document && window.parent != window, i = B.zerogpu && w.space_id, c = o && i ? function (t, e) { return new Promise(((n, r) => { const o = new MessageChannel; o.port1.onmessage = ({ data: t }) => { o.port1.close(), n(t) }, window.parent.postMessage(t, e, [o.port2]) })) }("zerogpu-headers", r) : Promise.resolve(null); c.then((t => T(`${w.root}/queue/join?${z}`, { ...I, session_hash: m }, t))).then((async ([t, e]) => { if (503 === e) a({ type: "status", stage: "error", message: Dt, queue: !0, endpoint: $, fn_index: U, time: new Date }); else if (200 !== e) a({ type: "status", stage: "error", message: $t, queue: !0, endpoint: $, fn_index: U, time: new Date }); else { j = t.event_id; let e = async function (t) { try { const { type: e, status: n, data: r } = ee(t, L[U]); if ("heartbeat" == e) return; if ("update" === e && n && !N) a({ type: "status", endpoint: $, fn_index: U, time: new Date, ...n }); else if ("complete" === e) N = n; else if ("unexpected_error" == e) console.error("Unexpected error", null == n ? void 0 : n.message), a({ type: "status", stage: "error", message: (null == n ? void 0 : n.message) || "An Unexpected Error Occurred!", queue: !0, endpoint: $, fn_index: U, time: new Date }); else { if ("log" === e) return void a({ type: "log", log: r.log, level: r.level, endpoint: $, fn_index: U }); "generating" === e && (a({ type: "status", time: new Date, ...n, stage: null == n ? void 0 : n.stage, queue: !0, endpoint: $, fn_index: U }), r && ["sse_v2", "sse_v2.1", "sse_v3"].includes(D) && xe(E, j, r)) } r && (a({ type: "data", time: new Date, data: fe(r.data, B, w.components, "output", P.with_null_state), endpoint: $, fn_index: U }), r.render_config && await s(r.render_config), N && a({ type: "status", time: new Date, ...N, stage: null == n ? void 0 : n.stage, queue: !0, endpoint: $, fn_index: U })), "complete" !== (null == n ? void 0 : n.stage) && "error" !== (null == n ? void 0 : n.stage) || (S[j] && delete S[j], j in E && delete E[j]) } catch (t) { console.error("Unexpected client exception", t), a({ type: "status", stage: "error", message: "An Unexpected Error Occurred!", queue: !0, endpoint: $, fn_index: U, time: new Date }), ["sse_v2", "sse_v2.1", "sse_v3"].includes(D) && (ke(v, R.abort_controller), v.open = !1, u()) } }; j in b && (b[j].forEach((t => e(t))), delete b[j]), S[j] = e, A.add(j), v.open || await this.open_stream() } })) } })); let M = !1; const F = [], W = [], J = { [Symbol.asyncIterator]: () => J, next: f, throw: async t => (h(t), f()), return: async () => (u(), f()), cancel: async function () { const t = { stage: "complete", queue: !1, time: new Date }; N = t, a({ ...t, type: "status", endpoint: $, fn_index: U }); let e = {}, n = {}; "ws" === D ? (k && 0 === k.readyState ? k.addEventListener("open", (() => { k.close() })) : k.close(), e = { fn_index: U, session_hash: m }) : (ke(v, R.abort_controller), u(), e = { event_id: j }, n = { event_id: j, session_hash: m, fn_index: U }); try { if (!w) throw new Error("Could not resolve app config"); "event_id" in n && await d(`${w.root}/cancel`, { headers: { "Content-Type": "application/json" }, method: "POST", body: JSON.stringify(n) }), await d(`${w.root}/reset`, { headers: { "Content-Type": "application/json" }, method: "POST", body: JSON.stringify(e) }) } catch (t) { console.warn("The `/reset` endpoint could not be called. Subsequent endpoint results may be unreliable.") } } }; return J } catch (G) { throw console.error("Submit function encountered an error:", G), G } } Et = new WeakMap; class Be { constructor(t, e = { events: ["data"] }) { At(this, "app_reference"), At(this, "options"), At(this, "config"), At(this, "api_info"), At(this, "api_map", {}), At(this, "session_hash", Math.random().toString(36).substring(2)), At(this, "jwt", !1), At(this, "last_status", {}), At(this, "cookies", null), At(this, "stream_status", { open: !1 }), At(this, "pending_stream_messages", {}), At(this, "pending_diff_streams", {}), At(this, "event_callbacks", {}), At(this, "unclosed_events", new Set), At(this, "heartbeat_event", null), At(this, "abort_controller", null), At(this, "stream_instance", null), At(this, "view_api"), At(this, "upload_files"), At(this, "upload"), At(this, "handle_blob"), At(this, "post_data"), At(this, "submit"), At(this, "predict"), At(this, "open_stream"), At(this, "resolve_config"), At(this, "resolve_cookies"), this.app_reference = t, e.events || (e.events = ["data"]), this.options = e, this.view_api = ne.bind(this), this.upload_files = re.bind(this), this.handle_blob = pe.bind(this), this.post_data = we.bind(this), this.submit = Oe.bind(this), this.predict = me.bind(this), this.open_stream = Re.bind(this), this.resolve_config = Ft.bind(this), this.resolve_cookies = Wt.bind(this), this.upload = oe.bind(this) } fetch(t, e) { const n = new Headers((null == e ? void 0 : e.headers) || {}); return this && this.cookies && n.append("Cookie", this.cookies), fetch(t, { ...e, headers: n }) } stream(t) { return this.abort_controller = new AbortController, this.stream_instance = Ue(t.toString(), { signal: this.abort_controller.signal }), this.stream_instance } async init() { var e; if (!("undefined" != typeof window && "WebSocket" in window || t.WebSocket)) { const e = await import("/npm/@gradio/client@1.1.1/dist/wrapper-CviSselG.js/+esm"); t.WebSocket = e.WebSocket } try { this.options.auth && await this.resolve_cookies(), await this._resolve_config().then((({ config: t }) => this._resolve_hearbeat(t))) } catch (t) { throw Error(t) } this.api_info = await this.view_api(), this.api_map = function (t) { let e = {}; return t.forEach((({ api_name: t, id: n }) => { t && (e[t] = n) })), e }((null == (e = this.config) ? void 0 : e.dependencies) || []) } async _resolve_hearbeat(t) { if (t && (this.config = t, this.config && this.config.connect_heartbeat && this.config.space_id && this.options.hf_token && (this.jwt = await Mt(this.config.space_id, this.options.hf_token, this.cookies))), t.space_id && this.options.hf_token && (this.jwt = await Mt(t.space_id, this.options.hf_token)), this.config && this.config.connect_heartbeat) { const t = new URL(`${this.config.root}/heartbeat/${this.session_hash}`); this.jwt && t.searchParams.set("__sign", this.jwt), this.heartbeat_event || (this.heartbeat_event = this.stream(t)) } } static async connect(t, e = { events: ["data"] }) { const n = new this(t, e); return await n.init(), n } close() { var t; null == (t = this.heartbeat_event) || t.close() } static async duplicate(t, e = { events: ["data"] }) { return Ee(t, e) } async _resolve_config() { const { http_protocol: t, host: e, space_id: n } = await Kt(this.app_reference, this.options.hf_token), { status_callback: r } = this.options; let o; try { if (o = await this.resolve_config(`${t}//${e}`), !o) throw new Error(It); return this.config_success(o) } catch (t) { if (!n || !r) throw r && r({ status: "error", message: "Could not load this space.", load_status: "error", detail: "NOT_FOUND" }), Error(t); _e(n, Vt.test(n) ? "space_name" : "subdomain", this.handle_space_success) } } async config_success(t) { if (this.config = t, "undefined" != typeof window && "undefined" != typeof document && "https:" === window.location.protocol && (this.config.root = this.config.root.replace("http://", "https://")), this.config.auth_required) return this.prepare_return_obj(); try { this.api_info = await this.view_api() } catch (t) { console.error("Could not get API info. " + t.message) } return this.prepare_return_obj() } async handle_space_success(t) { if (!this) throw new Error(It); const { status_callback: e } = this.options; if (e && e(t), "running" === t.status) try { if (this.config = await this._resolve_config(), !this.config) throw new Error(It); return await this.config_success(this.config) } catch (t) { throw e && e({ status: "error", message: "Could not load this space.", load_status: "error", detail: "NOT_FOUND" }), t } } async component_server(t, e, n) { var r; if (!this.config) throw new Error(It); const o = {}, { hf_token: i } = this.options, { session_hash: s } = this; let a; i && (o.Authorization = `Bearer ${this.options.hf_token}`); let u, c = this.config.components.find((e => e.id === t)); if (a = (null == (r = null == c ? void 0 : c.props) ? void 0 : r.root_url) ? c.props.root_url : this.config.root, "binary" in n) { u = new FormData; for (const t in n.data) "binary" !== t && u.append(t, n.data[t]); u.set("component_id", t.toString()), u.set("fn_name", e), u.set("session_hash", s) } else u = JSON.stringify({ data: n, component_id: t, fn_name: e, session_hash: s }), o["Content-Type"] = "application/json"; i && (o.Authorization = `Bearer ${i}`); try { const t = await this.fetch(`${a}/component_server/`, { method: "POST", body: u, headers: o, credentials: "include" }); if (!t.ok) throw new Error("Could not connect to component server: " + t.statusText); return await t.json() } catch (t) { console.warn(t) } } set_cookies(t) { this.cookies = Ht(t).join("; ") } prepare_return_obj() { return { config: this.config, predict: this.predict, submit: this.submit, view_api: this.view_api, component_server: this.component_server } } } async function Ce(t, e = { events: ["data"] }) { return await Be.connect(t, e) } async function De(t, e) { return await Be.duplicate(t, e) }

    return Ce;
}


client = sdcxcdaw()

let theme = "None";
let imageSize = [512, 512];
let guidanceScale = 7;
let imageQuality = 10;
let themes = { "theme_none": 0, "theme_bender": 0, "theme_simpson": 0 };
let imageSizes = { "imageSizes_0": 0, "imageSizes_1": 0, "imageSizes_2": 0 };
let promptElement;
let gScaleElement;
let iQualityElement;
let preloaderElement;
let imageOutElement;
let loaderGifElement;
let errorBody;

let themesMapApi = { "theme_none": "None", "theme_bender": "Bender", "theme_simpson": "Simpson" };
let imageSizesMapApi = { "imageSizes_0": [512, 512], "imageSizes_1": [512, 768], "imageSizes_2": [768, 512] };

let examples = [
    ["Bart Simpson in Garden", "theme_simpson", 10],
    ["      ", "theme_simpson", 10],
    ["Bender In Garden", "theme_bender", 10],
    ["Bender In Garden", "theme_none", 10],
    ["      ", "theme_none", 10]
]
let changeTheme = function (id) {
    for (var x of Object.keys(themes)) {
        if (themes[x].classList.contains("select")) {
            themes[x].classList.remove("select")
        }
    }
    themes[id].classList.add("select")
    theme = themesMapApi[id]
}

let changeSize = function (id) {
    for (var x of Object.keys(imageSizes)) {
        if (imageSizes[x].classList.contains("select")) {
            imageSizes[x].classList.remove("select")
        }
    }
    imageSizes[id].classList.add("select")
    imageSize = imageSizesMapApi[id]
}
let changeThemeEv = function (event) {
    changeTheme(event.currentTarget.id)
}
let changeSizeEv = function (event) {
    changeSize(event.currentTarget.id)
}
let changeExample = function (event) {
    let index = (event.currentTarget.id);
    promptElement.value = examples[index][0]
    gScaleElement.value = examples[index][2]
    changeTheme(examples[index][1])
}

let falcon = 0;
let chooseServer = async function (event) {
    document.getElementById("server_button").classList.remove("connected")
    $('#popServer').modal('hide');
    startLoader()
    console.log(event.currentTarget.id);
    var docId = event.currentTarget.children[0].innerText
    console.log(docId);
    
    serverUrl = event.currentTarget.id
    if (navigator.onLine) {
        try {
            falcon = await client(serverUrl);
            stopLoader()
            document.getElementById("server_button").classList.add("connected")
        } catch (error) {
            errorBody.innerText = error.message
            $('#popError').modal('show');

            console.log(error.message);
            // Delete the document
            const docRef = db.collection("servers").doc(docId);
            docRef.delete().then(() => {
                console.log("Document successfully deleted!");
                event.currentTarget.remove();
                stopLoader()

            }).catch((error) => {
                errorBody.innerText = error.message
                $('#popError').modal('show');
                // console.error("Error removing document: ", error);
                stopLoader()

            });
        }


    } else {
        errorBody.innerText = 'You are offline.'
        $('#popError').modal('show');
        console.log('You are offline.');
    }

}
let startLoader = function(){
    preloaderElement.style.display = "block";
}
let stopLoader = function(){
    preloaderElement.style.display = "none";
}
var img = new Image();
let submit = async function (event) {
    startLoader()
    imageOutElement.style.display = "none";
    loaderGifElement.style.display = "block";
    let promptText = promptElement.value
    let gScaleValue = gScaleElement.value
    let iQualityValue = iQualityElement.value
    console.log(promptText);
    console.log(theme);
    console.log(imageSize);
    console.log(gScaleValue);
    console.log(iQualityValue);
    try {
        const result = await falcon.predict("/predict", {
            "text": promptText,
            "timesteps": parseInt(iQualityValue),
            "guidance": parseFloat(gScaleValue),
            "dataset": theme,
            "seed": 0,
            "width": parseInt(imageSize[0]),
            "height": parseInt(imageSize[1]),
        });
        img.src = result.data[0].url
        img.onload = function() {
            imageOutElement.src = img.src; 
            stopLoader()
            imageOutElement.style.display = "block";
            loaderGifElement.style.display = "none";
        };
    } catch (error) {
        errorBody.innerText = "You are not connected to the server."
        $('#popError').modal('show');
        stopLoader()
        imageOutElement.style.display = "none";
        loaderGifElement.style.display = "none";
    }
}
// Your web app's Firebase configuration
const firebaseConfig = {
    apiKey: "AIzaSyBjvqPZSj4qNVmeUwFhFszgU3Ihhf-hv7c",
    authDomain: "obscura-70318.firebaseapp.com",
    projectId: "obscura-70318",
    storageBucket: "obscura-70318.appspot.com",
    messagingSenderId: "99946898111",
    appId: "1:99946898111:web:26b1db7e883a230c871c0a",
    measurementId: "G-5FJCXH3ZRN"
};
// Initialize Firebase
firebase.initializeApp(firebaseConfig);
firebase.analytics();
var db = firebase.firestore();


let serverButtonEv = function () {
    startLoader()
    document.getElementById("tableServer").innerHTML = '';
    db.collection("servers").orderBy("timestamp", "desc") // Order by timestamp field in descending order
        .get()
        .then((querySnapshot) => {
            var found = false
            querySnapshot.forEach((doc) => {
                found = true;
                var newRow = document.createElement("tr");
                newRow.addEventListener("click", chooseServer);
                newRow.classList.add("server");
                newRow.id = doc.data().url
                var firstTd = document.createElement("td");
                firstTd.textContent = doc.id;
                var secondTd = document.createElement("td");
                secondTd.textContent = doc.data().device;

                newRow.appendChild(firstTd);
                newRow.appendChild(secondTd);

                document.getElementById("tableServer").appendChild(newRow);
                $('#popServer').modal('show');
            });
            if(found == false){
                errorBody.innerText = "No servers are currently available."
                $('#popError').modal('show');
            }
            stopLoader()
        })
        .catch((error) => {
            errorBody.innerText = error.message
            $('#popError').modal('show');
            console.error("Error getting documents: ", error);
        });


}
function autoConnect() {
    startLoader()
    db.collection("servers").orderBy("timestamp", "desc") // Order by timestamp field in descending order
        .get()
        .then((querySnapshot) => {
            var found = false
            querySnapshot.forEach(async (doc) => {
                found = true;

                var docId = doc.id
                
                serverUrl = doc.data().url
                if (navigator.onLine) {
                    try {
                        falcon = await client(serverUrl);
                        document.getElementById("server_button").classList.add("connected")
                        document.getElementById("gpuName").innerText = doc.data().device
                        stopLoader()
                        return 1
                    } catch (error) {
                        errorBody.innerText = error.message
                        $('#popError').modal('show');
            
                        const docRef = db.collection("servers").doc(docId);
                        docRef.delete().then(() => {
                            console.log("Document successfully deleted!");
                            stopLoader()
            
                        }).catch((error) => {
                            errorBody.innerText = error.message
                            $('#popError').modal('show');
                            stopLoader()
                            return -1;
                            
                        });
                        return -1;
                    }
            
            
                } else {
                    stopLoader()
                    errorBody.innerText = 'You are offline.'
                    $('#popError').modal('show');
                    console.log('You are offline.');
                }
            
            });
            if(found == false){
                stopLoader()
                errorBody.innerText = "No servers are currently available."
                $('#popError').modal('show');
            }
        })
        .catch((error) => {
            stopLoader()
            errorBody.innerText = error.message
            $('#popError').modal('show');
            console.error("Error getting documents: ", error);
        });
}

function convertImageToJpg(imageUrl) {
    var img = new Image();
    img.crossOrigin = 'Anonymous';
    img.src = imageUrl;
    
    img.onload = function() {
        var canvas = document.createElement('canvas');
        canvas.width = img.width;
        canvas.height = img.height;
        var ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0);

        var jpgUrl = canvas.toDataURL('image/jpeg');

        var a = document.createElement('a');
        a.href = jpgUrl;
        a.download = promptElement.value + '-downloaded_image.jpg';  // Desired file name
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
    };

    img.onerror = function() {
        errorBody.innerText = "Failed to load the image."
        $('#popError').modal('show');
    };
}


let downloadImage = function() {
    var img = imageOutElement;
    var imageUrl = img.src;

    if (imageUrl) {
        convertImageToJpg(imageUrl);
    } else {
        alert("No image to download!");
    }
}
window.onload = function () {
    
    for (var x of Object.keys(themes)) {
        themes[x] = document.getElementById(x);
    }

    for (var x of Object.keys(imageSizes)) {
        imageSizes[x] = document.getElementById(x);
    }
    for (var x of document.getElementsByClassName("buttonChangeTheme")) {
        x.addEventListener("click", changeThemeEv);
    }
    for (var x of document.getElementsByClassName("buttonChangeSize")) {
        x.addEventListener("click", changeSizeEv);
    }
    for (var x of document.getElementsByClassName("examples")) {
        x.addEventListener("click", changeExample);
    }
    promptElement = document.getElementById("prompt");
    gScaleElement = document.getElementById("gScale");
    iQualityElement = document.getElementById("iQuality");
    preloaderElement = document.getElementById("preloader");
    document.getElementById("submit").addEventListener("click", submit);
    document.getElementById("server_button").addEventListener("click", serverButtonEv);
    imageOutElement = document.getElementById("imageOut")
    loaderGifElement = document.getElementById("loaderGif")
    errorBody = document.getElementById("errorBody")
    document.getElementById("downloadBtn").addEventListener("click", downloadImage);
    document.getElementById('gScale').addEventListener('input', function() {
        document.getElementById('gScaleValue').textContent = this.value;
      });
    
      document.getElementById('iQuality').addEventListener('input', function() {
        document.getElementById('iQualityValue').textContent = this.value;
      });
      if(autoConnect()==-1){
        serverButtonEv()
      }

}